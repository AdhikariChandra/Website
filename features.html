<html>
    <head>
        <link href="http://s3.amazonaws.com/codecademy-content/courses/ltp/css/shift.css" rel="stylesheet">
        <link rel="stylesheet" href="http://s3.amazonaws.com/codecademy-content/courses/ltp/css/bootstrap.css">
        <link rel="stylesheet" href="main.css">
        <link href='https://fonts.googleapis.com/css?family=Alegreya+Sans:100,100italic,400,400italic' rel='stylesheet' type='text/css'>
        
        <title> Features of Haskell </title>
        
        <!-- JavaScript provided by CallMeNick.com
        http://callmenick.com/post/animated-resizing-header-on-scroll-->
        
        <script src="res/js/classie.js"></script>
        <script>
            function init() {
                window.addEventListener('scroll', function(e){
                    var distanceY = window.pageYOffset ||       document.documentElement.scrollTop,
                        shrinkOn = 200,
                        header = document.querySelector("header");
                    if (distanceY > shrinkOn) {
                        classie.add(header,"smaller");
                    } else {
                        if (classie.has(header,"smaller")) {
                            classie.remove(header,"smaller");
                        }
                    }
                });
            }
            window.onload = init();
        </script>
    </head>
    
    <!-- BEGIN HEADER -->
    <header>
        <a href="index.html"><div class="logo"></div></a>
        <h2 class="syntax">
            <span class="syntax_main">main</span> <span class="syntax_equals">=</span> putStrLn <span class="syntax_string">"Features of Haskell."</span>
        </h2>
        
        <div class="nav_container">
            <div class="nav">
                <ul class="pull-left">
                    <li><a href="index.html">Intro To Haskell</a></li>
                    <li><a href="history.html">History</a></li>
                    <li><a href="features.html" class="highlighted">Features</a></li>
                </ul>
                <ul class="pull-right">
                    <li><a href="reasons.html">Why</a></li>
                    <li><a href="usage.html">Usage</a></li>
                    <li><a href="tutorials.html">Examples</a></li>
                    <li><a href="resources.html">Resources</a></li>
                </ul>
            </div>
        </div>
    </header>
    <!-- END HEADER -->
    
    <!-- BEGIN BODY -->
    <body>
        <div class="content_container">
            <h1 class="intro">Haskell is <span class="detail">purely-functional</span>.</h1>
            
            <p class="p_container">
                What does it mean for a program to be purely-functional? A purely functional programming language is one that executes its code using expressions, rather than statements which can affect the global state of a program.<br><br>Functional programming uses <span class="detail">first-class</span> functions, meaning they are treated like any other value and can be passed into other functions as arguments, or be the resulting return of a function. A functions that takes another function (or functions) as parameters are called higher-order functions, and are very useful when creating loops, and code refactoring.
                <br><br>
                Because functions in Haskell are pure, they cannot mutate variables. Take the following snippet of code for example. This is a function declaration named <span class="console">square</span> that expects an Integer as an argument, and returns an integer. It does not, however, mutate it's argument nor can it mutate any other values within the program.
            </p>
            
            <script src="https://gist.github.com/nathanielhernandez/0ac8af9c2698226d94eb832097b59ee6.js"></script>
            
            <p class="p_container">
                Since programs in Haskell allow you to only yield return values, there are no side-effects present. This is unlike functions within imperative languages, which can contain statements that can produce actions outside of return values. Because Haskell's functions produce no side-effects, it is considered to be <i>pure</i>.
            </p>
            
            <h1 class="intro">Haskell is <span class="detail">statically-typed</span>.</h1>
            
            <p class="p_container">
                Within Haskell, all expression types are determined at compile time rather than runtime. Your program will not compile if the correct function argument types are not passed into the funtion. This is of course, similar to program languages such as Java, C, and C++.
            <br><br>
                Haskell also has type inference, therefore types do not have to be directly declared when typing is obvious. The following code is identical, however on snippet declares types, where the other infers them.
            </p>
            
            <script src="https://gist.github.com/nathanielhernandez/4cd2c32f32ba35c4b9a4c0b5d2e9cb0d.js"></script>
            
            <h1 class="intro">Haskell is <span class ="detail">lazy</span>.</h1>
            
            <p class="p_container">
                Haskell is lazy. This isn't to say Haskell does not work hard, rather Haskell knows when it should work, and perhaps even more importantly, when it shouldn't. Haskell uses <i>lazy evaluation</i>, meaning expressions are not evaluated when bound to variables, but rather are evaluated when they are needed within the program.
            <br><br>
                Sometimes called "call-by-need" evaluation, lazy evaluation can help improve efficiency within code, because it is absent of recomputation. Lazy evaluation can also reduce the memory impact a program has upon its environment.
            <br><br>
                One example of lazy evaluation within Since functions do not evaluate their arguments, we can implement function
                
                
            </p>
            <h1 class="intro">Haskell has <span class="detail">concurrency</span>.</h1>
            
            <p class="p_container">
                GHC (Glasgow Haskell Compiler) supports serval types of parallel and concurrent programing from threads and locks to other forms of parallel and concurrent programming such as actors, CSP-style concurrency, nested data parrallelism, and Intel Concurrent Collections.
                <br><br>
                Communication between seperate threads can be performed using messages, Haskell variables, and MVar shared state memory. Using concurrency within Haskell is as easy as importing the <span class="console">Control.Concurrent</span> library into your program.</p>
            
            <script src="https://gist.github.com/nathanielhernandez/cca7b804d7a17ae635ffb264da0e9807.js"></script>
            
            <h1 class="intro">Haskell is <span class="detail">awesome</span>.</h1>
            
            <p class="p_container">There I said it. 10 bonus points!</p>

        </div>
    </body>
</html>